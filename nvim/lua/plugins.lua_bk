disable_file_type = {
    'help',
    'packer',
    'lspsagafinder',
    'TelescopePrompt',
    'moving.lua',
    'HopChar',
    'NeogitPopup',
    'NeogitStatus',
    'mason',
    'alpha',
}

lsp_servers = {
    'lua_ls',
    'bashls',
    'denols',
    'dockerls',
    'gopls',
    'jsonls',
    'ts_ls',
    'intelephense',
    'rust_analyzer',
}

require("lazy").setup({
    -- Configurations for Nvim LSP
    {
        'neovim/nvim-lspconfig',
        config = function()
            local on_attach = function(client, bufnr)
                if client.server_capabilities.documentSymbolProvider then
                    local navic = require("nvim-navic")
                    navic.attach(client, bufnr)
                end
            end
            -- Set up lspconfig.
            local capabilities = require("cmp_nvim_lsp").default_capabilities()
            local lspconfig = require('lspconfig')
            local servers = lsp_servers
            local lsp_flags = {
                debounce_text_changes = 100,
            }
            local function go_org_imports(wait_ms)
                local params = vim.lsp.util.make_range_params()
                params.context = { only = { "source.organizeImports" } }
                local result = vim.lsp.buf_request_sync(0, "textDocument/codeAction", params, wait_ms)
                for cid, res in pairs(result or {}) do
                    for _, r in pairs(res.result or {}) do
                        if r.edit then
                            local enc = (vim.lsp.get_client_by_id(cid) or {}).offset_encoding or "utf-16"
                            vim.lsp.util.apply_workspace_edit(r.edit, enc)
                        end
                    end
                end
            end

            vim.api.nvim_create_autocmd("BufWritePre", {
                pattern = "*.go",
                callback = function()
                    go_org_imports()
                end
            })
        end,
    },

    -- linter/formatter
    {
        'jose-elias-alvarez/null-ls.nvim',
        config = function()
            local null_ls = require("null-ls")
            null_ls.setup({
                -- lua
                null_ls.builtins.formatting.stylua,
                -- spell
                null_ls.builtins.completion.spell,
                -- shell
                null_ls.builtins.diagnostics.shellcheck,
            })
        end,
        dependencies = { "nvim-lua/plenary.nvim" }
    },

    -- debug
    {
        "rcarriga/nvim-dap-ui",
        dependencies = {
            "mfussenegger/nvim-dap",
            "leoluz/nvim-dap-go",
            "nvim-neotest/nvim-nio",
        },
        config = function()
            require('dap-go').setup()
            require('dapui').setup()

            local opts = { silent = true }
            vim.keymap.set('n', leader .. 'dc', [[:lua require ]dap'.continue()<CR>]], opts)
            vim.keymap.set('n', leader .. 'dn', [[:lua require'dap'.step_over()<CR>]], opts)
            vim.keymap.set('n', leader .. 'di', [[:lua require'dap'.step_into()<CR>]], opts)
            vim.keymap.set('n', leader .. 'do', [[:lua require'dap'.step_out()<CR>]], opts)
            vim.keymap.set('n', leader .. 'db', [[:lua require'dap'.toggle_breakpoint()<CR>]], opts)
            vim.keymap.set('n', leader .. leader .. 'd', [[:lua require'dapui'.toggle()<CR>]], opts)
            vim.keymap.set('n', leader .. leader .. 'df', [[:lua require'dapui'.eval()<CR>]], opts)

            -- debug が開始したらdapui を起動
            require 'dap'.listeners.before['event_initialized']['custom'] = function(session, body)
                require("dapui").open()
            end
            -- debug が終了したらdapui を終了
            require 'dap'.listeners.before['event_terminated']['custom'] = function(session, body)
                require 'dapui'.close()
            end

            local dap = require("dap")
            dap.adapters.go = function(callback, config)
                local stdout = vim.loop.new_pipe(false)
                local handle
                local pid_or_err
                local port = 38697
                local opts = {
                    stdio = { nil, stdout },
                    args = { "dap", "-l", "127.0.0.1:" .. port },
                    detached = true
                }
                handle, pid_or_err = vim.loop.spawn("dlv", opts, function(code)
                    stdout:close()
                    handle:close()
                    if code ~= 0 then
                        print('dlv exited with code', code)
                    end
                end)
                assert(handle, 'Error running dlv: ' .. tostring(pid_or_err))
                stdout:read_start(function(err, chunk)
                    assert(not err, err)
                    if chunk then
                        vim.schedule(function()
                            require('dap.repl').append(chunk)
                        end)
                    end
                end)
                -- Wait for delve to start
                vim.defer_fn(
                    function()
                        callback({ type = "server", host = "127.0.0.1", port = port })
                    end,
                    100)
            end
            dap.configurations.go = {
                {
                    type = "go",
                    name = "Debug",
                    request = "launch",
                    mode = "debug",
                    program = "${file}",
                },
                {
                    type = "go",
                    name = "Debug(args)",
                    request = "launch",
                    mode = "debug",
                    program = "${file}",
                    args = function()
                        local args_string = vim.fn.input('Arguments: ')
                        return vim.split(args_string, " +")
                    end,
                }
            }

            dap.adapters.php = {
                type = "executable",
                command = "node",
                args = { "~/ghq/github.com/xdebug/vscode-php-debug/out/phpDebug.js" }
            }
            dap.configurations.php = {
                {
                    type = 'php',
                    request = 'launch',
                    name = 'Listen for Xdebug',
                    port = 9000
                }
            }
        end,
    },


    {
        'kevinhwang91/nvim-hlslens',
        config = function()
            require('hlslens').setup()
        end
    },


    -- Colorscheme
    {
        --'olimorris/onedarkpro.nvim',
        'sainnhe/gruvbox-material',
        config = function()
            -- require("onedarkpro").setup({
            --   dark_theme = "onedark_dark", -- The default dark theme
            -- })
            vim.cmd [[ colorscheme gruvbox-material ]]
        end
    },
    -- color
    { 'gko/vim-coloresque' },

     -- 末尾の空白スペース可視化
    {
        'bronson/vim-trailing-whitespace',
        config = function()
            vim.g.extra_whitespace_ignored_filetypes = disable_file_type
        end
    },

  
    -- Delibiters
    -- カッコの編集を便利するプラグイン
    { 'tpope/vim-surround' },


    -- moving
    -- 括弧移動強化
    { 'andymass/vim-matchup' },
    -- カーソル移動
    { 'mg979/vim-visual-multi' },
    {
        'smoka7/hop.nvim',
        version = "*",
        config = function()
            require('hop').setup {}
            local opts = { silent = true }
            vim.keymap.set('n', 'fs', "<cmd>lua require'hop'.hint_char1()<cr>", opts)
            vim.cmd([[ highlight default HopNextKey1 guifg=#fff200 gui=bold blend=0 ]])
            vim.cmd([[ highlight default HopNextKey2 guifg=#ede8eb blend=0 ]])
        end
    },

    -- support
    {
        'reireias/vim-cheatsheet',
        config = function()
            vim.g['cheatsheet#cheat_file'] = vim.env.DOTFILES_PATH .. '/Doc/cheetsheet.md'
        end
    },

    {
        "folke/trouble.nvim",
        opts = {},
        cmd = "Trouble",
        keys = {},
    }
})
